/**
 * Document - generic document object to be formatted and displayed
 * @author Daniel Ringwalt (ringw)
 */

if (! Vex.Flow.Backend) Vex.Flow.Backend = {};

/**
 * Vex.Flow.Backend.IR - return measures from intermediate JSON representation
 * @constructor
 */
Vex.Flow.Backend.IR = function() {
  this.documentObject = null;
}

/**
 * "Parse" an existing IR document object (not necessarily a Document instance)
 * @param object The original document object
 */
Vex.Flow.Backend.IR.prototype.parse = function(object) {
  if (! Vex.Flow.Backend.IR.appearsValid(object))
    throw new Vex.RERR("InvalidArgument",
                       "IR object must be a valid document");
  
  // Force a first-class document object to get all measures
  if (typeof object.getNumberOfMeasures == "function"
      && typeof object.getMeasure == "function") {
    var numMeasures = object.getNumberOfMeasures();
    for (var i = 0; i < numMeasures; i++) object.getMeasure(i);
  }
  this.documentObject = object;
  this.valid = true;
}

/**
 * Returns true if the passed-in code parsed without errors.
 *
 * @return {Boolean} True if code is error-free.
 */
Vex.Flow.Backend.IR.prototype.isValid = function() { return this.valid; }

/**
 * Class method.
 * Returns true if the argument appears to a valid document object.
 * Used when automatically detecting VexFlow IR.
 *
 * @return {Boolean} True if object looks like a valid document.
 */
Vex.Flow.Backend.IR.appearsValid = function(object) {
  return typeof object == "object" && object.type == "document";
}

/**
 * Number of measures in the document
 *
 * @return {Number} Total number of measures
 */
Vex.Flow.Backend.IR.prototype.getNumberOfMeasures = function() {
  return this.documentObject.measures.length;
}

/**
 * Create the ith measure from this.measures[i]
 *
 * @return {Vex.Flow.Measure} ith measure as a Measure object
 */
Vex.Flow.Backend.IR.prototype.getMeasure = function(i) {
  return new Vex.Flow.Measure(this.documentObject.measures[i]);
}

/**
 * @return {Array} Stave connectors
 * Each stave connector has a type, array of parts, and one or more true
 * out of system_start, measure_start, and system_end.
 */
Vex.Flow.Backend.IR.prototype.getStaveConnectors = function() {
  if (typeof this.documentObject.getStaveConnectors == "function")
    return this.documentObject.getStaveConnectors();
  return [];
}

/**
 * Vex.Flow.Document - generic container of measures generated by a backend
 * @constructor
 */
Vex.Flow.Document = function(data, options) {
  if (arguments.length > 0) this.init(data, options);
}

Vex.Flow.Document.backends = [Vex.Flow.Backend.IR, Vex.Flow.Backend.MusicXML];

Vex.Flow.Document.prototype.init = function(data, options) {
  this.options = {};
  Vex.Merge(this.options, options);
  this.measures = new Array();
  if (! data) {
    this.backend = null;
    return;
  }

  // Optionally pass constructor function for backend
  var backends = (typeof this.options.backend == "function")
                 ? [this.options.backend] : Vex.Flow.Document.backends;
  for (var i = 0; i < backends.length; i++) {
    var Backend = backends[i];
    if (Backend.appearsValid(data)) {
      this.backend = new Backend();
      this.backend.parse(data);
      if (! this.backend.isValid())
        throw new Vex.RERR("ParseError", "Could not parse document data");
    }
  }
  if (! this.backend)
    throw new Vex.RERR("ParseError", "Data in document is not supported");

  this.type = "document";
}

/**
 * Create a formatter with a copy of the document
 * (formatter may add clefs, etc. when formatting document)
 * @param {Function} Class of formatter
 * @return {Vex.Flow.DocumentFormatter} Document formatter with document copy
 */
Vex.Flow.Document.prototype.getFormatter = function(formatterClass) {
  var Formatter = formatterClass;
  if (typeof FormatterClass != "function")
    Formatter = Vex.Flow.DocumentFormatter.Liquid; // default class
  return new Formatter(new Vex.Flow.Document(this));
}

/**
 * Number of measures in the document
 * @return {Number} Total number of measures
 */
Vex.Flow.Document.prototype.getNumberOfMeasures = function() {
  return this.backend.getNumberOfMeasures();
}

/**
 * @param {Number} Zero-indexed measure number
 * @return {Number} Actual measure number (default: add 1 to argument)
 */
Vex.Flow.Document.prototype.getMeasureNumber = function(m) {
  return (typeof this.backend.getMeasureNumber == "function")
         ? this.backend.getMeasureNumber(m) : m + 1;
}

/**
 * Retrieve the ith measure (zero-indexed).
 * @param {Number} The zero-indexed measure to access.
 * @return {Vex.Flow.Measure} Measure object for corresponding measure
 */
Vex.Flow.Document.prototype.getMeasure = function(m) {
  if (m in this.measures) return this.measures[m];
  var measure = this.backend.getMeasure(m);
  if (typeof console != "undefined" && console.assert)
      console.assert(measure instanceof Vex.Flow.Measure,
                     "Backend must return valid Vex.Flow.Measure");
  this.measures[m] = measure;
  return measure;
}

Vex.Flow.Document.prototype.getNumberOfParts = function() {
  return this.getMeasure(0).getNumberOfParts(); }

/**
 * Connector options from backend
 * Single connectors are automatically added at the start of the system
 * and for barlines within a single part.
 * @return {Array} array of objects with properties:
 *    type (bracket, brace, single, etc), parts (array of part numbers),
 *    system_start/system_end/measure_start (true/false)
 */
Vex.Flow.Document.prototype.getStaveConnectors = function() {
  if (typeof this.staveConnectors != "object") {
    this.staveConnectors = this.backend.getStaveConnectors().slice(0);
    var haveSingleSystemStart = false; // add if necessary
    var numParts = this.getNumberOfParts();
    var lastPart = numParts - 1;
    this.staveConnectors.forEach(function(connector) {
      if (connector.type == "single" && connector.parts[0] == 0
          && connector.parts[connector.parts.length - 1] == lastPart
          && (connector.system_start || connector.measure_start))
        haveSingleSystemStart = true;
    });
    if (! haveSingleSystemStart)
      this.staveConnectors.push({
        type: "single", system_start: true, parts: [0, lastPart]});

    // Add barlines to each part if necessary
    var partsHaveBarlines = [];
    this.staveConnectors.forEach(function(connector) {
      if (connector.type == "single" && connector.parts.length == 1
          && connector.measure_start && connector.system_end)
        partsHaveBarlines[connector.parts[0]] = true;
    });
    for (var i = 0; i < numParts; i++)
      if (! partsHaveBarlines[i])
        this.staveConnectors.push({
          type: "single", parts: [i], measure_start: true, system_end: true
        });
  }
  return this.staveConnectors;
}
